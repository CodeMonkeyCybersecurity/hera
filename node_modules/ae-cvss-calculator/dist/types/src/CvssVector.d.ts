export interface VectorComponentValue {
    name: string;
    shortName: string;
    abbreviatedName?: string;
    jsonSchemaName?: string;
    description: string;
    hide?: boolean;
}
export interface NumberVectorComponentValue extends VectorComponentValue {
    value: number;
}
export interface ChangedNumberVectorComponentValue extends NumberVectorComponentValue {
    changedValue: number;
}
export interface BooleanVectorComponentValue extends VectorComponentValue {
    value: boolean;
}
export interface VectorComponent<T extends VectorComponentValue> {
    readonly name: string;
    readonly shortName: string;
    readonly subCategory?: string;
    description: string;
    readonly values: T[];
    worseCaseValue?: T;
    readonly baseMetricEquivalent?: VectorComponent<VectorComponentValue>;
    readonly baseMetricEquivalentMapper?: (value: VectorComponentValue) => VectorComponentValue;
}
export interface ComponentCategory {
    readonly name: string;
    readonly description: string;
}
export interface BaseScoreResult {
    readonly vector: string;
    readonly overall: number;
    readonly normalized: boolean;
}
export interface MultiScoreResult extends BaseScoreResult {
    readonly base: number | undefined;
    readonly exploitability: number | undefined;
    readonly impact: number | undefined;
    readonly environmental: number | undefined;
    readonly temporal: number | undefined;
    readonly modifiedImpact: number | undefined;
}
export interface V4ScoreResult extends BaseScoreResult {
    readonly base: number | undefined;
    readonly baseMetricsOnly: number | undefined;
    readonly environmental: number | undefined;
    readonly threat: number | undefined;
}
export interface SingleScoreResult extends BaseScoreResult {
}
declare class CachedVectorScores<R extends BaseScoreResult> {
    protected vector: string;
    protected normalize: boolean;
    protected scores: R;
    constructor(vector: string, normalize: boolean, scores: R);
    isUpToDate(vector: string, normalize: boolean): boolean;
    getScores(): R;
}
export declare abstract class CvssVector<R extends BaseScoreResult> {
    protected components: Map<VectorComponent<VectorComponentValue>, VectorComponentValue>;
    protected vectorChangedListeners: ((vector: CvssVector<R>) => void)[];
    protected cachedScores: CachedVectorScores<R> | undefined;
    protected constructor(initialVector?: string);
    calculateScores(normalize?: boolean): R;
    protected abstract calculateScoresInternal(normalize: boolean): R;
    abstract getVectorPrefix(): string;
    abstract getVectorName(): string;
    abstract getRegisteredComponents(): Map<ComponentCategory, VectorComponent<VectorComponentValue>[]>;
    abstract createJsonSchema(): any;
    fillBaseMetrics(): void;
    abstract fillAverageVector(): void;
    abstract fillRandomBaseVector(): void;
    abstract isBaseFullyDefined(): boolean;
    abstract isAnyBaseDefined(): boolean;
    getComponents(): Map<VectorComponent<VectorComponentValue>, VectorComponentValue>;
    clearComponents(): void;
    clearSpecifiedComponents(components: VectorComponent<any>[]): void;
    addVectorChangedListener(listener: (vector: CvssVector<R>) => void): void;
    normalizeVector(vector: string): string;
    findComponent(nameOrShortName: string): VectorComponent<VectorComponentValue> | undefined;
    applyVector(vector: string): void;
    applyVectorCount(vector: string): number;
    applyComponentString(setComponent: string, setValue: string, notifyListeners?: boolean): boolean;
    applyComponentStringSilent(setComponent: string, setValue: string, notifyListeners?: boolean): boolean;
    applyComponent(setComponent: VectorComponent<VectorComponentValue>, setValue: VectorComponentValue, notifyListeners?: boolean): void;
    protected applyVectorPartsIf(vector: string, scoreType: (vector: CvssVector<R>) => number, lower: boolean): number;
    applyVectorPartsIfLower(vector: string, scoreType: (vector: CvssVector<R>) => number): number;
    applyVectorPartsIfHigher(vector: string, scoreType: (vector: CvssVector<R>) => number): number;
    applyVectorPartsIfLowerVector(vector: CvssVector<R>, scoreType: (vector: CvssVector<R>) => number): number;
    applyVectorPartsIfHigherVector(vector: CvssVector<R>, scoreType: (vector: CvssVector<R>) => number): number;
    getComponent<T extends VectorComponentValue>(component: VectorComponent<T>): T;
    getComponentByString(component: string): VectorComponentValue;
    getComponentByStringOpt(component: string): VectorComponentValue | null;
    size(): number;
    getFirstDefinedComponent<T extends VectorComponentValue>(components: VectorComponent<T>[]): T;
    toString(forceAllComponents?: boolean, categories?: Map<ComponentCategory, VectorComponent<VectorComponentValue>[]>, showOnlyDefinedComponents?: boolean): string;
    toStringDefinedParts(): string;
    protected isCategoryFullyDefined(category: ComponentCategory): boolean;
    isCategoryPartiallyDefined(category: ComponentCategory): boolean;
    protected round(value: number, precision: number): number;
    protected roundUp(value: number): number;
    protected normalizeScore(score: number, max: number): number;
    protected mapRange(value: number, min: number, max: number, newMin: number, newMax: number): number;
    protected pickRandomDefinedComponentValue(component: VectorComponent<VectorComponentValue>): VectorComponentValue | undefined;
    clone(): CvssVector<R>;
    diffVector(checkVector: CvssVector<R>): CvssVector<R>;
    applyEnvironmentalMetricsOntoBase(): void;
    protected isComponentValueDefined(component: VectorComponentValue | undefined): boolean;
    static _reorderAttributeSeverityOrder(attributes: VectorComponentValue[]): VectorComponentValue[][];
}
export {};
