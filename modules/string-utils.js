/**
 * String Utilities
 *
 * Pure functions for string manipulation and comparison.
 * No external dependencies, fully testable.
 */

/**
 * Calculate Levenshtein distance between two strings
 * Used for typosquatting detection and domain similarity analysis
 *
 * @param {string} str1 - First string to compare
 * @param {string} str2 - Second string to compare
 * @returns {number} Edit distance (minimum number of single-character edits)
 *
 * @example
 * levenshteinDistance('google', 'gogle') // Returns 1
 * levenshteinDistance('microsoft', 'microsfot') // Returns 1
 */
export function levenshteinDistance(str1, str2) {
  const matrix = [];

  for (let i = 0; i <= str2.length; i++) {
    matrix[i] = [i];
  }

  for (let j = 0; j <= str1.length; j++) {
    matrix[0][j] = j;
  }

  for (let i = 1; i <= str2.length; i++) {
    for (let j = 1; j <= str1.length; j++) {
      if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(
          matrix[i - 1][j - 1] + 1, // substitution
          matrix[i][j - 1] + 1,      // insertion
          matrix[i - 1][j] + 1       // deletion
        );
      }
    }
  }

  return matrix[str2.length][str1.length];
}

/**
 * Calculate string similarity for homograph detection
 * Returns similarity ratio between 0 and 1
 *
 * @param {string} str1 - First string to compare
 * @param {string} str2 - Second string to compare
 * @returns {number} Similarity ratio (0.0 to 1.0, where 1.0 is identical)
 *
 * @example
 * calculateStringSimilarity('google', 'google') // Returns 1.0
 * calculateStringSimilarity('google', 'gogle') // Returns 0.83
 * calculateStringSimilarity('google', 'facebook') // Returns 0.125
 */
export function calculateStringSimilarity(str1, str2) {
  const longer = str1.length > str2.length ? str1 : str2;
  const shorter = str1.length > str2.length ? str2 : str1;

  if (longer.length === 0) return 1.0;

  const editDistance = levenshteinDistance(longer, shorter);
  return (longer.length - editDistance) / longer.length;
}

/**
 * Detect homograph attacks (Unicode characters that look like ASCII)
 * Checks for mixed scripts or suspicious Unicode characters
 *
 * @param {string} hostname - Domain name to check
 * @returns {boolean} True if homograph attack detected
 *
 * @example
 * detectHomographAttack('google.com') // Returns false
 * detectHomographAttack('gооgle.com') // Returns true (Cyrillic 'о')
 */
export function detectHomographAttack(hostname) {
  // Check for mixed scripts or suspicious Unicode characters
  const suspiciousChars = /[а-я]|[α-ω]|[а-я]|[\u0400-\u04FF]|[\u0370-\u03FF]/i; // Cyrillic, Greek
  const hasNonASCII = /[^\x00-\x7F]/.test(hostname);
  const hasMixedScript = suspiciousChars.test(hostname);

  // Common homograph targets
  const commonTargets = ['google', 'microsoft', 'apple', 'amazon', 'facebook', 'github'];
  const isTargetLookalike = commonTargets.some(target => {
    const similarity = calculateStringSimilarity(hostname.toLowerCase(), target);
    return similarity > 0.8 && similarity < 1.0;
  });

  return hasNonASCII || hasMixedScript || isTargetLookalike;
}

/**
 * Detect Domain Generation Algorithm (DGA) patterns
 * DGA domains are randomly generated by malware for C&C communication
 *
 * @param {string} hostname - Domain name to check
 * @returns {boolean} True if DGA pattern detected
 *
 * @example
 * detectDGAPattern('google.com') // Returns false
 * detectDGAPattern('xjkl3mq9pzrt.com') // Returns true
 */
export function detectDGAPattern(hostname) {
  const domain = hostname.split('.')[0];

  // DGA characteristics
  const hasRandomPattern = /^[a-z]{8,20}$/.test(domain); // Long random strings
  const hasNumberMix = /^[a-z0-9]{10,}$/.test(domain) && /\d/.test(domain);
  const hasConsonantClusters = /[bcdfghjklmnpqrstvwxyz]{4,}/.test(domain);
  const lowVowelRatio = (domain.match(/[aeiou]/g) || []).length / domain.length < 0.2;

  return (hasRandomPattern || hasNumberMix) && (hasConsonantClusters || lowVowelRatio);
}

/**
 * Calculate typosquatting score for a domain
 * Compares domain to list of popular targets
 *
 * @param {string} domain - Domain to check
 * @returns {number} Typosquatting score (0.0 to 1.0, higher = more suspicious)
 *
 * @example
 * calculateTyposquattingScore('google.com') // Returns 0.0 (exact match)
 * calculateTyposquattingScore('gooogle.com') // Returns 0.83 (typo)
 */
export function calculateTyposquattingScore(domain) {
  // List of popular domains to check against
  const popularDomains = [
    'google.com', 'facebook.com', 'amazon.com', 'microsoft.com',
    'apple.com', 'netflix.com', 'paypal.com', 'twitter.com',
    'instagram.com', 'linkedin.com', 'github.com', 'stackoverflow.com'
  ];

  let maxSimilarity = 0;

  for (const popular of popularDomains) {
    const similarity = calculateStringSimilarity(domain, popular);
    maxSimilarity = Math.max(maxSimilarity, similarity);

    // Check for common typosquatting patterns
    if (domain.includes(popular.split('.')[0]) && domain !== popular) {
      maxSimilarity = Math.max(maxSimilarity, 0.8);
    }
  }

  return maxSimilarity;
}

/**
 * Detect suspicious domain patterns
 * Returns array of detected patterns
 *
 * @param {string} hostname - Domain name to check
 * @returns {string[]} Array of detected pattern types
 *
 * @example
 * detectSuspiciousDomainPatterns('google.com') // Returns []
 * detectSuspiciousDomainPatterns('gooogle.tk') // Returns ['suspicious_tld', 'typosquatting_google']
 */
export function detectSuspiciousDomainPatterns(hostname) {
  const patterns = [];

  // Suspicious TLDs
  const suspiciousTLDs = ['.tk', '.ml', '.ga', '.cf', '.pw', '.top', '.click', '.download'];
  if (suspiciousTLDs.some(tld => hostname.endsWith(tld))) {
    patterns.push('suspicious_tld');
  }

  // Typosquatting patterns
  const legitimateDomains = ['google.com', 'microsoft.com', 'github.com', 'facebook.com'];
  legitimateDomains.forEach(legit => {
    if (hostname !== legit && calculateStringSimilarity(hostname, legit) > 0.7) {
      patterns.push('typosquatting_' + legit.replace('.com', ''));
    }
  });

  // Subdomain abuse
  const subdomainCount = hostname.split('.').length - 2;
  if (subdomainCount > 3) {
    patterns.push('excessive_subdomains');
  }

  // URL shortener domains
  const shorteners = ['bit.ly', 'tinyurl.com', 't.co', 'goo.gl', 'ow.ly'];
  if (shorteners.includes(hostname)) {
    patterns.push('url_shortener');
  }

  return patterns;
}

/**
 * Generate unique session ID using cryptographically secure random UUID
 *
 * SECURITY FIX P1-NEW: Uses crypto.randomUUID() instead of Math.random()
 * Math.random() is NOT cryptographically secure and predictable
 * Only ~52 bits of entropy vs 128 bits from crypto.randomUUID()
 *
 * @returns {string} Unique session ID with 'session_' prefix
 *
 * @example
 * generateSessionId() // Returns 'session_a1b2c3d4-e5f6-7890-abcd-ef1234567890'
 */
export function generateSessionId() {
  return 'session_' + crypto.randomUUID();
}
